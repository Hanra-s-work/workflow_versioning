name: doxygen_generator

on:
  push:
    tags:
      - "v*.*.*"
    branches:
      - doxygen_generation
  workflow_dispatch:


# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: write
  pages: write
  id-token: write

# The environment variables used for generation and upload
env:
  # Variables for managing required containers
  DOCKER_NAME: hanralatalliard/doxygen
  CODING_STYLE_CONTAINER: ghcr.io/epitech/coding-style-checker:latest
  # Variables for managin the tags
  SETUP_FILE: setup.py
  TAG_FILE: version.txt
  IS_RELEASE: is_release.txt
  LATEST_TAG: ""
  # variables managing name publishing
  COMMIT_TITLE: "There is no title"
  COMMIT_MESSAGE: "There is no message"
  #Variables for the extras scripts
  DOXYFILE: bonus/doxygen_docker/Doxyfile
  MAN_INSTALL_PATH: bonus/doxygen_docker/man/installer.sh
  HTML_SERVER_SPAWNER_PATH: bonus/doxygen_docker/html/launch_server.sh
  # Variables for managing ntfy notification system
  NOTIFY_CHANNEL: ntfy.sh/is_up #${{ secrets.NOTIFY_ZAPPY }}
  NOTIFY_LOCATION: ${GITHUB_REPOSITORY}:${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
  # Variables for specifying build locations
  HTML_GENERATION: html
  TEMPORARY_FOLDER: tmp_documentation
  OUTPUT_GENERATION: documentation
  # Variables for specifying the outputs to be cached/published
  LINUX_BINARY_FOLDER: "./linux_binaries"
  MAC_MONE_BINARY_FOLDER: "./mac_mone_binaries"
  MAC_INTEL_BINARY_FOLDER: "./mac_intel_binaries"
  # Variable containing the reference key for the cache of each main section
  CACHE_KEY: doxygen-cache-key
  CACHE_KEY_CLEANED: doxygen-cache-key-cleaned
  LINUX_CACHE_KEY_BUILD: linux-cache-key
  MAC_MONE_CACHE_KEY_BUILD: mac-mone-cache-key
  MAC_INTEL_CACHE_KEY_BUILD: mac-intel-cache-key
  # Variables containing a more friendly name concerning their role and the destination architectures
  EXECUTABLES: "./zappy_ai ./zappy_gui ./zappy_server"
  EXECUTABLES_LINUX: "./zappy_linux_ai ./zappy_linux_gui ./zappy_linux_server"
  EXECUTABLES_MAC_INTEL: "./zappy_mac_intel_ai ./zappy_mac_intel_gui ./zappy_mac_intel_server"
  EXECUTABLES_MAC_MONE: "./zappy_mac_apple_chip_ai ./zappy_mac_apple_chip_gui ./zappy_mac_apple_chip_server"


# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

# The jobs in charge of building everything
jobs:
  check_coding_style:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Getting the latest version of (coding-style) ${{env.CODING_STYLE_CONTAINER}}
      run: docker pull ${{env.CODING_STYLE_CONTAINER}}
    - name: Run ${{env.CODING_STYLE_CONTAINER}}
      run: |
        CODING_STYLE=coding_style_data
        mkdir -p $CODING_STYLE
        docker run --rm -i -v "$(pwd)/src/server":/mnt/delivery -v "$(pwd)/$CODING_STYLE":/mnt/reports $CODING_STYLE_CONTAINER "/mnt/delivery" "/mnt/reports"
    - name: Checking the results
      run: |
        CONTENT="$(cat coding_style_data/coding-style-reports.log)"
        ILLEGAL_FILES_FOUND=0
        if [ "$CONTENT" == "" ]; then
            echo "No errors were found"
            exit 0
        fi
        while IFS= read -r LINE; do
            FILE=$(echo $LINE | cut -d ':' -f 1)
            LINE_NUMBER=$(echo $LINE | cut -d ':' -f 2)
            LEVEL=$(echo $LINE | cut -d ':' -f 3 | cut -d ' ' -f 2)
            ERROR_CODE=$(echo $LINE | cut -d ':' -f 4)
            echo "::error file=$FILE,line=$LINE_NUMBER,endLine=0,title=$LEVEL coding style error::$ERROR_CODE"
            ILLEGAL_FILES_FOUND=1
        done <<<"$CONTENT"
        if [ $ILLEGAL_FILES_FOUND -eq 1 ]; then
            curl -H "Title: Coding style errors" -H "Priority: default" -H 'Tags: warning' -d "The coding style reported errors for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
            exit 1
        else
            exit 0
        fi

  build_doxygen:
    runs-on: ubuntu-latest
    needs: check_coding_style
    if: success()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Build doxygen docker
        run: |
          docker pull ${{env.DOCKER_NAME}}
      - name: Create required folders
        run: |
          mkdir -p ${{env.OUTPUT_GENERATION}} ${{env.OUTPUT_GENERATION}}/${{env.HTML_GENERATION}}
      - name: Clean repository
        run: |
          make fclean
          cd ./src/ai/
          make fclean_env
      - name: Create dummy page for html renders
        run: |
          HTML_CONTENT='<!DOCTYPE html><html lang="en"><head>'
          HTML_CONTENT+=" <meta charset='UTF-8'>"
          HTML_CONTENT+=" <meta name='viewport' content='width=device-width, initial-scale=1.0'>"
          HTML_CONTENT+=" <title>Dummy Page</title>"
          HTML_CONTENT+=" <style>"
          HTML_CONTENT+="   body {font-family: Arial, sans-serif;background-color: #f8f9fa;color: #333;margin: 0;padding: 0;display: flex;justify-content: center;align-items: center;height: 100vh;}"
          HTML_CONTENT+="   .container {text-align: center;padding: 20px;background: #fff;border: 1px solid #ddd;border-radius: 8px;box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);}"
          HTML_CONTENT+="   h1 {color: #007bff;}"
          HTML_CONTENT+="   p {font-size: 1.1em;}"
          HTML_CONTENT+="   a {color: #007bff;text-decoration: none;}"
          HTML_CONTENT+="   a:hover {text-decoration: underline;}"
          HTML_CONTENT+=" </style>"
          HTML_CONTENT+="</head><body>"
          HTML_CONTENT+="<body>"
          HTML_CONTENT+=" <div class='container'>"
          HTML_CONTENT+="   <h1>Welcome to the Dummy Documentation</h1>"
          HTML_CONTENT+="   <p>This is a placeholder page for generated documentation.<br>If you see this is that the doxyfile in the action did not generate html content (or generated it in the wrong place)</p>"
          HTML_CONTENT+="   <p>To learn more, visit <a href="https://www.doxygen.org/">Doxygen</a>.</p>"
          HTML_CONTENT+=" </div>"
          HTML_CONTENT+="</body></html>"
          echo -e "$HTML_CONTENT" > ${{env.OUTPUT_GENERATION}}/${{env.HTML_GENERATION}}/index.html
      - name: Run doxygen docker
        run: |
          RUN_COMMAND="cd /app && cp ${{env.DOXYFILE}} ./Doxyfile && doxygen ; exit $?"
          docker run -i -v "$(pwd)":"/app" -v "$(pwd)/${{env.OUTPUT_GENERATION}}":"/${{env.OUTPUT_GENERATION}}" ${{env.DOCKER_NAME}} /bin/bash -c "$RUN_COMMAND"
          if [ $? -ne 0 ]
          then
            curl -H "Title: Build failed" -H "Priority: default" -H 'Tags: warning' -d "The documentation generation failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
            exit 1
          fi
      - name: Reclaim ownership
        run: |
          echo "Owning the generated content (replacing root by the current user account)"
          sudo chown $USER:$USER -Rv ${{env.OUTPUT_GENERATION}}
          echo "Granting all users read-write rights on the files"
          chmod a+rw -Rv ${{env.OUTPUT_GENERATION}}
      - name: Display generated content
        run: |
          ls -a
          echo "Displaying the content of: ${{env.OUTPUT_GENERATION}}"
          ls -a ${{env.OUTPUT_GENERATION}}
          echo "Displaying the content of: ${{env.OUTPUT_GENERATION}}/${{env.HTML_GENERATION}}"
          ls -a ${{env.OUTPUT_GENERATION}}/${{env.HTML_GENERATION}}
      - name: Save cache
        id: cache-save
        uses: actions/cache@v4
        with:
          key: ${{env.CACHE_KEY}}
          path: ${{env.OUTPUT_GENERATION}}
          enableCrossOsArchive: true

  clean_up_generation:
    runs-on: ubuntu-latest
    needs: build_doxygen
    if: success()
    env:
      ICON_PATH: bonus/doxygen_docker/favicon/
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Get generated documentation
        id: cache-documentation-restore
        uses: actions/cache@v4
        with:
          key: ${{ env.CACHE_KEY }}
          enableCrossOsArchive: true
          path: ${{ env.OUTPUT_GENERATION }}
          restore-keys: |
            doxygen-cache-key
            cache-key-doxygen
            doxygen_cache_key
            cache_key_doxygen
      - name: Making temporary folder permanent
        run: |
          echo "Content at './'"  
          ls -a ./
          echo "Copying content of ${{ env.OUTPUT_GENERATION }} to ${{env.TEMPORARY_FOLDER}}"
          mkdir -p ${{ env.TEMPORARY_FOLDER}}
          cp -rf ${{ env.OUTPUT_GENERATION }} ${{env.TEMPORARY_FOLDER}}
          echo "Content of: ${{ env.TEMPORARY_FOLDER }}/"
          ls -a ${{ env.TEMPORARY_FOLDER }}/
          echo "Content of: ${{ env.OUTPUT_GENERATION }}/"
          ls -a ${{ env.OUTPUT_GENERATION }}/
      - name: Listing content of temporary folder
        run: |
          echo "Contents of ${{env.TEMPORARY_FOLDER}}"
          ls -a ${{env.TEMPORARY_FOLDER}}
      - name: Copy the icons to the generated documentation
        run: |
          echo "Content of temporary folder: ${{ env.TEMPORARY_FOLDER }}"
          DOCUMENTATION=$(find ${{ env.TEMPORARY_FOLDER }}/* -maxdepth 1 -type d)
          for i in ${DOCUMENTATION[@]}
          do
            if [[ "$(basename "$i")" == "man" ]]; then
              echo "Skipping 'man' directory"
              continue
            fi
            if [[ "$(basename "$i")" == "html" ]]; then
              echo "Skipping 'html' directory"
              continue
            fi
            echo "\$i = '$i'"
            FINAL_PATH="$i/files/icon"
            echo "Final path = $FINAL_PATH"
            mkdir -p "$FINAL_PATH"
            cp -r ${{env.ICON_PATH}}/* "$FINAL_PATH"
            ls -a -ls --color=auto "$FINAL_PATH"
          done
      - name: Generate latex if present
        run: |
          if [ -e "${{env.TEMPORARY_FOLDER}}/${{ env.OUTPUT_GENERATION }}/latex" ]; then
            CWD=$(pwd)
            cd "${{env.TEMPORARY_FOLDER}}/${{ env.OUTPUT_GENERATION }}/latex"
            if [ -e "Makefile" ]; then
              CONT_NAME=loxygene
              COMMAND="cd /app && make"
              # docker run -i -v "$(pwd)":"/app" --name "$CONT_NAME" ${{env.DOCKER_NAME}} /bin/bash -c "$COMMAND"
              # docker stop "$CONT_NAME"
              # docker rm "$CONT_NAME"
            else
              echo "No Makefile found, not generating anything"
            fi
            cd $CWDxs
          else
            echo "No latex folder found, not generating anything"
          fi
      - name: Inject install file if man is present
        run: |
          if [ -e "${{env.TEMPORARY_FOLDER}}/${{ env.OUTPUT_GENERATION }}/man" ]; then
            CWD=$(pwd)
            FILE_NAME="install_man.sh"
            cd "${{env.TEMPORARY_FOLDER}}/${{ env.OUTPUT_GENERATION }}/man"
            cp $CWD/${{env.MAN_INSTALL_PATH}} ./$FILE_NAME
            chmod a+x $FILE_NAME
            cd $CWD
          else
            echo "There was no man generated"
          fi
      - name: Inject server spawner file if html is present
        run: |
          if [ -e "${{env.TEMPORARY_FOLDER}}/${{ env.OUTPUT_GENERATION }}/html" ]; then
            CWD=$(pwd)
            FILE_NAME="launch_server.sh"
            cd "${{env.TEMPORARY_FOLDER}}/${{ env.OUTPUT_GENERATION }}/html"
            cp $CWD/${{env.HTML_SERVER_SPAWNER_PATH}} ./$FILE_NAME
            chmod a+x $FILE_NAME
            cd $CWD
          else
            echo "There was no html generated"
          fi
      - name: Save cache
        id: cache-save
        uses: actions/cache@v4
        with:
          key: ${{env.CACHE_KEY_CLEANED}}
          path: ${{env.TEMPORARY_FOLDER}}
          enableCrossOsArchive: true


  publish_html:
    # environment variables that are for the github pages
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    # The system on which we are running the actions
    runs-on: ubuntu-latest
    needs: clean_up_generation
    if: success()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get generated documentation
        id: html-cache-restore
        uses: actions/cache@v4
        with:
          key: ${{ env.CACHE_KEY_CLEANED }}
          path: ${{ env.OUTPUT_GENERATION }}
          enableCrossOsArchive: true
          restore-keys: |
            doxygen-cache-key
            cache-key-doxygen
            doxygen_cache_key
            cache_key_doxygen

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload selected content
          path: ${{env.OUTPUT_GENERATION}}/${{env.HTML_GENERATION}}

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

  build_project_linux:
    runs-on: ubuntu-latest
    needs: check_coding_style
    if: success()
    env:
      LINUX_BINARIES_FILE_STORER: "cache_paths.txt"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Pull Docker image
        run: docker pull epitechcontent/epitest-docker
      - name: Compile code
        run: |
          docker run -v "$(pwd)":"/home/" -i epitechcontent/epitest-docker /bin/bash -c "cd /home && make && make clean"
          if [ $? -ne 0 ]
          then
            curl -H "Title: Build failed" -H "Priority: high" -H 'Tags: warning,skull' -d "The build failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
            exit 1
          fi

      - name: Rename binaries
        run: |
          IFS=' ' read -r -a EXE_ARRAY <<<"${{env.EXECUTABLES}}"
          IFS=' ' read -r -a LINUX_EXE_ARRAY <<<"${{env.EXECUTABLES_LINUX}}"

          if [ ${#EXE_ARRAY[@]} -ne ${#LINUX_EXE_ARRAY[@]} ]; then
              echo "::error ::Mismatch between the number of executables in EXECUTABLES and EXECUTABLES_LINUX"
              exit 1
          fi

          BIN_FOLD=${{env.LINUX_BINARY_FOLDER}}
          mkdir -p $BIN_FOLD

          for i in "${!EXE_ARRAY[@]}"; do
              EXE="${EXE_ARRAY[$i]}"
              LEXE="${LINUX_EXE_ARRAY[$i]}"

              if [ ! -e "$EXE" ]; then
                  echo "::error file=$EXE,line=1,endLine=0,title='NOT FOUND' ::The file '$EXE' does not exist"
                  exit 1
              else
                  mv $EXE $BIN_FOLD/$LEXE
                  echo "$BIN_FOLD/$LEXE" >> ${{env.LINUX_BINARIES_FILE_STORER}}
              fi
          done
      
      - name: listing created binaries
        run: |
          ls -a
          echo "Contents of : ${{env.LINUX_BINARY_FOLDER}}"
          ls -a ${{env.LINUX_BINARY_FOLDER}}

      - name: Save cache
        id: cache-save
        uses: actions/cache@v4
        with:
          key: ${{env.LINUX_CACHE_KEY_BUILD}}
          enableCrossOsArchive: true
          path: ${{env.LINUX_BINARY_FOLDER}}
  
  build_project_mac_apple_chip:
    runs-on: macos-latest
    needs: check_coding_style
    if: success()
    env:
      MAC_MONE_BINARIES_FILE_STORER: "cache_paths.txt"
      MAC_BINARY_FOLDER: mac_bin
      MAC_PYTHON_VERSION: 3.11
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Install Xcode Command Line Tools (for c and cpp)
        run: |
          xcode-select --print-path
          if [ $? -eq 0 ]; then
            echo "Command line tools are already installed."
          else
            # Install command line tools
            xcode-select --install
            if [ $? -ne 0 ]; then
              curl -H "Title: xcode installation failed" -H "Priority: default" -H 'Tags: warning,apple,arrow_down_small' -d "The xcode installation failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
              exit 1
            fi
          fi
      - name: Install SFML (the old way)
        run: |
          SFML_FOLDER="my_sfml.tar.gz"
          SFML_DESTINATION="$(pwd)/extracted_sfml"
          curl -L https://www.sfml-dev.org/files/SFML-2.1-osx-gcc-universal.tar.gz -o $SFML_FOLDER
          if [ $? -ne 0 ]
          then
            curl -H "Title: SFML installation failed" -H "Priority: default" -H 'Tags: warning,apple,beer,desktop_computer,arrow_down_small' -d "The sfml installation failed for ${{env.NOTIFY_LOCATION}}: Failed to download the SFML archive" ${{env.NOTIFY_CHANNEL}}
            exit 1
          fi
          ls
          mkdir -p $SFML_DESTINATION
          tar -xvf "$SFML_FOLDER" -C "$SFML_DESTINATION"
          if [ $? -ne 0 ]
          then
            curl -H "Title: SFML installation failed" -H "Priority: default" -H 'Tags: warning,apple,beer,desktop_computer,arrow_down_small' -d "The sfml installation failed for ${{env.NOTIFY_LOCATION}}: Failed to extract the SFML archivexs" ${{env.NOTIFY_CHANNEL}}
            exit 1
          fi
          cd $SFML_DESTINATION
          cd *
          sudo ./install.sh
          if [ $? -ne 0 ]
          then
            curl -H "Title: SFML installation failed" -H "Priority: default" -H 'Tags: warning,apple,beer,desktop_computer,arrow_down_small' -d "The sfml installation failed for ${{env.NOTIFY_LOCATION}}: Failed to run the install.sh script" ${{env.NOTIFY_CHANNEL}}
            exit 1
          fi
      - name: Install CSFML via Homebrew
        run: |
          if brew ls --versions csfml > /dev/null; then
            echo "csfml is installed"
          else
            DEPENDENCIES="csfml"
            echo "csfml is not installed"
            brew install $DEPENDENCIES
            if [ $? -ne 0 ]
            then
              curl -H "Title: $DEPENDENCIES installation failed" -H "Priority: default" -H 'Tags: warning,apple,beer,desktop_computer,arrow_down_small' -d "The $DEPENDENDCIES installation failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
              exit 1
            fi
          fi
          if brew ls --versions openal-soft > /dev/null; then
            echo "openal-soft is installed"
          else
            DEPENDENCIES="openal-soft"
            echo "openal-soft is not installed"
            brew install $DEPENDENCIES
            if [ $? -ne 0 ]
            then
              curl -H "Title: $DEPENDENCIES installation failed" -H "Priority: default" -H 'Tags: warning,apple,beer,desktop_computer,arrow_down_small' -d "The $DEPENDENDCIES installation failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
              exit 1
            fi
          fi
          if brew ls --versions pkg-config > /dev/null; then
            echo "pkg-config is installed"
          else
            DEPENDENCIES="pkg-config"
            echo "pkg-config is not installed"
            brew install $DEPENDENCIES
            if [ $? -ne 0 ]
            then
              curl -H "Title: $DEPENDENCIES installation failed" -H "Priority: default" -H 'Tags: warning,apple,beer,desktop_computer,arrow_down_small' -d "The $DEPENDENDCIES installation failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
              exit 1
            fi
          fi
          if brew ls --versions cmake > /dev/null; then
            echo "cmake is installed"
          else
            DEPENDENCIES="cmake --cask"
            echo "cmake is not installed"
            brew install $DEPENDENCIES
            if [ $? -ne 0 ]
            then
              curl -H "Title: $DEPENDENCIES installation failed" -H "Priority: default" -H 'Tags: warning,apple,beer,desktop_computer,arrow_down_small' -d "The $DEPENDENDCIES installation failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
              exit 1
            fi
          fi
      - name: Update paths for dependecy builds
        run: |
          echo 'export PATH="/opt/homebrew/opt/openal-soft/bin:$PATH"' >> /Users/runner/.bash_profile
          export LDFLAGS="-L/opt/homebrew/opt/openal-soft/lib"
          export CPPFLAGS="-I/opt/homebrew/opt/openal-soft/include"
          export PKG_CONFIG_PATH="/opt/homebrew/opt/openal-soft/lib/pkgconfig"
      - name: Install python ${{env.MAC_PYTHON_VERSION}}
        run: |
          if brew ls --versions python@${{env.MAC_PYTHON_VERSION}} > /dev/null; then
            echo "python@${{env.MAC_PYTHON_VERSION}} is installed"
          else
            DEPENDENCIES="python@${{env.MAC_PYTHON_VERSION}}"
            echo "python@${{env.MAC_PYTHON_VERSION}} is not installed"
            brew install $DEPENDENCIES
            if [ $? -ne 0 ]
            then
              curl -H "Title: $DEPENDENCIES installation failed" -H "Priority: default" -H 'Tags: warning,apple,beer,desktop_computer,arrow_down_small' -d "The $DEPENDENDCIES installation failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
              exit 1
            fi
          fi
          if brew ls --versions python-tk@${{env.MAC_PYTHON_VERSION}} > /dev/null; then
            echo "python-tk@${{env.MAC_PYTHON_VERSION}} is installed"
          else
            DEPENDENCIES="python-tk@${{env.MAC_PYTHON_VERSION}}"
            echo "python-tk@${{env.MAC_PYTHON_VERSION}} is not installed"
            brew install $DEPENDENCIES
            if [ $? -ne 0 ]
            then
              curl -H "Title: $DEPENDENCIES installation failed" -H "Priority: default" -H 'Tags: warning,apple,beer,desktop_computer,arrow_down_small' -d "The $DEPENDENDCIES installation failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
              exit 1
            fi
          fi
      - name: Re-create the python environement
        run: |
          cd src/ai
          make noisy fclean_env
          if [ $? -ne 0 ]
          then
            curl -H "Title: Env removal failed" -H "Priority: default" -H 'Tags: warning,apple,snake,wastebasket' -d "The environement removal failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
            exit 1
          fi
          make noisy create_environement install_dependencies
          if [ $? -ne 0 ]
          then
            curl -H "Title: Env removal failed" -H "Priority: default" -H 'Tags: warning,apple,snake,new' -d "The environement creation failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
            exit 1
          fi
      - name: Delete existing compilation
        run: |
          make fclean
          if [ $? -ne 0 ]
          then
            curl -H "Title: Clean failed" -H "Priority: high" -H 'Tags: warning' -d "The cleaning of existing compilations failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
            exit 1
          fi
          
      - name: Compile code
        run: |
          echo "Updating specific variables in the terminal in order to make sure that the compilation goes well"
          export LDFLAGS="-L/opt/homebrew/opt/openal-soft/lib"
          export CPPFLAGS="-I/opt/homebrew/opt/openal-soft/include"
          export PKG_CONFIG_PATH="/opt/homebrew/opt/openal-soft/lib/pkgconfig"
          echo "Compiling the data"
          make && make clean
          if [ $? -ne 0 ]
          then
            curl -H "Title: Build failed" -H "Priority: high" -H 'Tags: warning' -d "The build failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
            exit 1
          fi

      - name: Rename binaries
        run: |
          IFS=' ' read -r -a EXE_ARRAY <<<"${{env.EXECUTABLES}}"
          IFS=' ' read -r -a MAC_MONE_EXE_ARRAY <<<"${{env.EXECUTABLES_MAC_MONE}}"

          if [ ${#EXE_ARRAY[@]} -ne ${#MAC_MONE_EXE_ARRAY[@]} ]; then
              echo "::error ::Mismatch between the number of executables in EXECUTABLES and EXECUTABLES_MAC_MONE"
              exit 1
          fi

          BIN_FOLD=${{env.MAC_MONE_BINARY_FOLDER}}
          mkdir -p $BIN_FOLD

          for i in "${!EXE_ARRAY[@]}"; do
              EXE="${EXE_ARRAY[$i]}"
              MEXE="${MAC_MONE_EXE_ARRAY[$i]}"

              if [ ! -e "$EXE" ]; then
                  echo "::error file=$EXE,line=1,endLine=0,title='NOT FOUND' ::The file '$EXE' does not exist"
                  exit 1
              else
                  mv $EXE $BIN_FOLD/$MEXE
                  echo "$BIN_FOLD/$MEXE" >> ${{env.MAC_MONE_BINARIES_FILE_STORER}}
              fi
          done
      - name: listing created binaries
        run: |
          ls -a
          echo "Contents of : ${{env.MAC_MONE_BINARY_FOLDER}}"
          ls -a ${{env.MAC_MONE_BINARY_FOLDER}}

      - name: Save cache
        id: cache-save
        uses: actions/cache@v4
        with:
          key: ${{env.MAC_MONE_CACHE_KEY_BUILD}}
          enableCrossOsArchive: true
          path: ${{env.MAC_MONE_BINARY_FOLDER}}

  build_project_mac_intel_chip:
    runs-on: macos-12
    needs: check_coding_style
    if: success()
    env:
      MAC_INTEL_BINARIES_FILE_STORER: "cache_paths.txt"
      MAC_PYTHON_VERSION: 3.11
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Install Xcode Command Line Tools (for c and cpp)
        run: |
          xcode-select --print-path
          if [ $? -eq 0 ]; then
            echo "Command line tools are already installed."
          else
            # Install command line tools
            xcode-select --install
            if [ $? -ne 0 ]; then
              curl -H "Title: xcode installation failed" -H "Priority: default" -H 'Tags: warning,apple,arrow_down_small' -d "The xcode installation failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
              exit 1
            fi
          fi
      - name: Install SFML and CSFML via Homebrew
        run: |
          brew install sfml csfml
          if [ $? -ne 0 ]
          then
            curl -H "Title: SFML and CSFML installation failed" -H "Priority: default" -H 'Tags: warning,apple,beer,desktop_computer,arrow_down_small' -d "The sfml and csfml installation failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
            exit 1
          fi
      - name: Install python ${{env.MAC_PYTHON_VERSION}}
        run: |
          if brew ls --versions python@${{env.MAC_PYTHON_VERSION}} > /dev/null; then
            echo "python@${{env.MAC_PYTHON_VERSION}} is installed"
          else
            DEPENDENCIES="python@${{env.MAC_PYTHON_VERSION}}"
            echo "python@${{env.MAC_PYTHON_VERSION}} is not installed"
            brew install $DEPENDENCIES
            if [ $? -ne 0 ]
            then
              curl -H "Title: $DEPENDENCIES installation failed" -H "Priority: default" -H 'Tags: warning,apple,beer,desktop_computer,arrow_down_small' -d "The $DEPENDENDCIES installation failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
              exit 1
            fi
          fi
          if brew ls --versions python-tk@${{env.MAC_PYTHON_VERSION}} > /dev/null; then
            echo "python-tk@${{env.MAC_PYTHON_VERSION}} is installed"
          else
            DEPENDENCIES="python-tk@${{env.MAC_PYTHON_VERSION}}"
            echo "python-tk@${{env.MAC_PYTHON_VERSION}} is not installed"
            brew install $DEPENDENCIES
            if [ $? -ne 0 ]
            then
              curl -H "Title: $DEPENDENCIES installation failed" -H "Priority: default" -H 'Tags: warning,apple,beer,desktop_computer,arrow_down_small' -d "The $DEPENDENDCIES installation failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
              exit 1
            fi
          fi
      - name: Re-create the python environement
        run: |
          cd src/ai
          make noisy fclean_env
          if [ $? -ne 0 ]
          then
            curl -H "Title: Env removal failed" -H "Priority: default" -H 'Tags: warning,apple,snake,wastebasket' -d "The environement removal failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
            exit 1
          fi
          make noisy create_environement install_dependencies
          if [ $? -ne 0 ]
          then
            curl -H "Title: Env removal failed" -H "Priority: default" -H 'Tags: warning,apple,snake,new' -d "The environement creation failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
            exit 1
          fi
      - name: Delete existing compilation
        run: |
          make fclean
          if [ $? -ne 0 ]
          then
            curl -H "Title: Clean failed" -H "Priority: high" -H 'Tags: warning' -d "The cleaning of existing compilations failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
            exit 1
          fi
          
      - name: Compile code
        run: |
          make && make clean
          if [ $? -ne 0 ]
          then
            curl -H "Title: Build failed" -H "Priority: high" -H 'Tags: warning' -d "The build failed for ${{env.NOTIFY_LOCATION}}" ${{env.NOTIFY_CHANNEL}}
            exit 1
          fi

      - name: Rename binaries
        run: |
          IFS=' ' read -r -a EXE_ARRAY <<<"${{env.EXECUTABLES}}"
          IFS=' ' read -r -a EXECUTABLES_MAC_INTEL <<<"${{env.EXECUTABLES_MAC_INTEL}}"

          if [ ${#EXE_ARRAY[@]} -ne ${#EXECUTABLES_MAC_INTEL[@]} ]; then
              echo "::error ::Mismatch between the number of executables in EXECUTABLES and EXECUTABLES_MAC_INTEL"
              exit 1
          fi

          BIN_FOLD=${{env.MAC_INTEL_BINARY_FOLDER}}
          mkdir -p $BIN_FOLD

          for i in "${!EXE_ARRAY[@]}"; do
              EXE="${EXE_ARRAY[$i]}"
              MEXE="${EXECUTABLES_MAC_INTEL[$i]}"

              if [ ! -e "$EXE" ]; then
                  echo "::error file=$EXE,line=1,endLine=0,title='NOT FOUND' ::The file '$EXE' does not exist"
                  exit 1
              else
                  mv $EXE $BIN_FOLD/$MEXE
                  echo "$BIN_FOLD/$MEXE" >> ${{env.MAC_INTEL_BINARIES_FILE_STORER}}
              fi
          done
      - name: listing created binaries
        run: |
          ls -a
          echo "Contents of : ${{env.MAC_INTEL_BINARY_FOLDER}}"
          ls -a ${{env.MAC_INTEL_BINARY_FOLDER}}

      - name: Save cache
        id: cache-save
        uses: actions/cache@v4
        with:
          key: ${{env.MAC_INTEL_CACHE_KEY_BUILD}}
          enableCrossOsArchive: true
          path: ${{env.MAC_INTEL_BINARY_FOLDER}}

  export_other_formats_when_present:
    runs-on: ubuntu-latest
    needs: [build_project_linux, build_project_mac_apple_chip, build_project_mac_intel_chip, clean_up_generation]
    if: success()
    env:
      MAC_MON_ZIP_NAME: mac_apple_chip.zip
      MAC_INTEL_ZIP_NAME: mac_intel_chip.zip
      LINUX_ZIP_NAME: linux.zip
      DOCUMENTATION_ZIP_NAME: documentation.zip
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get generated documentation
        id: cache-documentation-restore
        uses: actions/cache@v4
        with:
          key: ${{ env.CACHE_KEY_CLEANED }}
          enableCrossOsArchive: true
          path: ${{ env.TEMPORARY_FOLDER }}
          restore-keys: |
            doxygen-cache-key
            cache-key-doxygen
            doxygen_cache_key
            cache_key_doxygen
      
      - name: Get linux binaries
        id: cache-linux-restore
        uses: actions/cache@v4
        with:
          key: ${{ env.LINUX_CACHE_KEY_BUILD }}
          enableCrossOsArchive: true
          path: ${{ env.LINUX_BINARY_FOLDER }}
          restore-keys: |
            linux-cache-key
            cache-key-linux
            linux_cache_key
            cache_key_linux
      
      - name: Get generated mac apple chip binaries
        id: cache-mac-apple-chip-restore
        uses: actions/cache@v4
        with:
          key: ${{ env.MAC_MONE_CACHE_KEY_BUILD }}
          enableCrossOsArchive: true
          path: ${{ env.MAC_MONE_BINARY_FOLDER }}
          restore-keys: |
            mac-mone-cache-key
            cache-key-mac-mone
            mac_mone_cache_key
            cache_key_mac_mone
            mac-apple-chip-cache-key
            cache-key-mac-apple-chip
            mac_apple_chip_cache_key
            cache_key_mac_apple_chip
      
      - name: Get generated mac intel binaries
        id: cache-mac-intel-restore
        uses: actions/cache@v4
        with:
          key: ${{ env.MAC_INTEL_CACHE_KEY_BUILD }}
          enableCrossOsArchive: true
          path: ${{ env.MAC_INTEL_BINARY_FOLDER }}
          restore-keys: |
            mac-intel-cache-key
            cache-key-mac-intel
            mac_intel_cache_key
            cache_key_mac_intel
            mac-intel-chip-cache-key
            cache-key-mac-intel-chip
            mac_intel_chip_cache_key
            cache_key_mac_intel_chip

      - name: List directory content
        run: |
          ls -a

      - name: Get Latest Tag
        id: get_latest_tag
        run: |
          echo "Getting tags"
          # git fetch --tags # Make sure to fetch the tags first
          echo "Updated the list"
          latest_tag=$(git tag --list "v*" | sort -rV | head -n 1)
          echo "Latest tag = $latest_tag"
          if [ "$latest_tag" == "" ]; then
            echo "No tags found matching 'v*'."
            latest_tag="v1.0.0"
            echo "Using a default tag: $latest_tag"
          else
            echo "Latest Tag: $latest_tag"
          fi
          echo "$latest_tag" > ${{env.TAG_FILE}}
          echo "LATEST_TAG=$latest_tag" >> $GITHUB_ENV
          echo -e "\n\n\n\n\n\n\n\n\n"
          echo "new_tag = $latest_tag"
          echo "env.new_tag = ${{env.tag_file}}"
          echo "cat env.new_tag = $(cat ${{env.TAG_FILE}})"
          echo "env.LATEST_TAG = ${{env.LATEST_TAG}}"
          echo -e "\n\n\n\n\n\n\n\n\n"

      - name: Check if Latest Tag is a Release
        id: is_release
        run: |
          latest_tag="$(cat ${{env.TAG_FILE}})"
          is_release="false"
          latest_updated_tag=$(git tag --list "v*" | sort -rV | head -n 1)
          if [[ $latest_updated_tag == $latest_tag ]]; then
            is_release="true"
          fi
          echo "$is_release" > ${{env.IS_RELEASE}}
          echo -e "\n\n\n\n\n\n\n\n\n"
          echo "Is_release = $is_release"
          echo "env.Is_release = ${{env.is_release}}"
          echo "cat env.Is_release = $(cat ${{env.is_release}})"
          echo -e "\n\n\n\n\n\n\n\n\n"

      - name: Increment Tag Version
        id: increment_tag
        run: |
          is_release="$(cat ${{env.IS_RELEASE}})"
          latest_tag="$(cat ${{env.TAG_FILE}})"
          echo "ls = '$(ls)'"
          echo "is_release = $is_release"
          echo "latest_tag = $latest_tag"
          if [[ $is_release == "true" ]]; then
            # Parse the latest tag and increment the version component you want
            # Example: Convert "v1.2.3" to "v1.2.4"
            new_tag="${latest_tag/v/}"  # Remove the leading "v"
            echo "new_tag = $new_tag"
            IFS='.' read -ra version <<< "$new_tag"
            echo "declare -p version = $(declare -p $version)"
            echo "declare -p version[0] = $(declare -p ${version[0]})"
            echo "declare -p version[1] = $(declare -p ${version[1]})"
            echo "declare -p version[2] = $(declare -p ${version[2]})"
            echo "version[2]+1 = $(expr "${version[2]}" + 1)"
            echo "version[*] = ${version[*]}"
            echo "version = ${version}"
            echo "#version = ${#version}"
            echo "version[0] = ${version[0]}"
            echo "version[1] = ${version[1]}"
            echo "version[2] = ${version[2]}"
            version[2]=$(expr "${version[2]}" + 1)  # Increment the third version component
            echo "Version = ${version[*]}"
            new_tag="v${version[0]}.${version[1]}.${version[2]}"
            echo "New Tag: $new_tag"
            echo "$new_tag" > ${{env.TAG_FILE}}
            echo "NEW_TAG=$new_tag" >> $GITHUB_ENV
          else
            echo "Latest tag is not a release. Skipping tag increment."
          fi
          echo -e "\n\n\n\n\n\n\n\n\n"
          echo "new_tag = $new_tag"
          echo "env.NEW_TAG = ${{env.NEW_TAG}}"
          echo "env.is_release = $(cat ${{env.IS_RELEASE}})"
          echo "cat env.new_tag = $(cat ${{env.TAG_FILE}})"
          echo "cat env.is_release = $(cat ${{env.IS_RELEASE}})"
          echo -e "\n\n\n\n\n\n\n\n\n"

      - name: Update author
        run: |
          git config --local user.name "${{secrets.USER_NAME_E}}"
          git config --local user.email "${{secrets.USER_EMAIL_E}}"

      - name: Get tag title
        run: |
          TAG_NAME="${{env.LATEST_TAG}}"
          echo "Found file=$TAG_NAME"
          COMMIT_TITLE="$(git tag -l --format='%(subject)' $TAG_NAME)"
          if [ "$COMMIT_TITLE" = "" ]
          then
            COMMIT_TITLE="$(git log --format=%s -n 1)"
          fi
          COMMIT_TITLE="$TAG_NAME - $COMMIT_TITLE"
          echo "Commit title: $COMMIT_TITLE"
          echo "COMMIT_TITLE=$COMMIT_TITLE" >> $GITHUB_ENV

      - name: Extract Tag Info
        id: extract_tag_info
        run: |
          if [ "${{env.LATEST_TAG}}" = "" ]
          then
            echo "Tag name not found"
            TAG_NAME="v0.0.0"
          else
            TAG_NAME="${{env.LATEST_TAG}}"
          fi
          echo "TAG NAME content = $TAG_NAME"
          COMMIT_MESSAGE=$(git tag -l --format='%(contents)' $TAG_NAME)
          echo "Commit message content = $COMMIT_MESSAGE"
          if [[ -n "$COMMIT_MESSAGE" ]]; then
            COMMIT_MESSAGE=$(git log --format=%s -n 1)
          fi
          if [ "$COMMIT_MESSAGE" = "" ]
          then
            COMMIT_MESSAGE="There is no message\n$(cat ./README.md)"
          else
            COMMIT_MESSAGE="${COMMIT_MESSAGE}\n$(cat ./README.md)"
          fi
          COMMIT_MESSAGE="${COMMIT_MESSAGE}\n\`\`\`log\n$(git log --format=%s -n 50)\n\`\`\`"
          echo "Commit message final content = '$COMMIT_MESSAGE'"
          # COMMIT_MESSAGE_ESCAPED=$(echo "$COMMIT_MESSAGE" | awk '{printf "%s\\n", $0}')
          # echo "COMMIT_MESSAGE=$COMMIT_MESSAGE_ESCAPED" >> $GITHUB_ENV
          {
            echo "COMMIT_MESSAGE<<EOH"
            echo -e "$COMMIT_MESSAGE"
            echo EOH
          } >> $GITHUB_ENV

      - name: Restore the documentation to it's original directory
        run: |
          cp -rvf ${{env.TEMPORARY_FOLDER}}/* ${{env.OUTPUT_GENERATION}}

      - name: Display current restored cache
        run: |
          ls -a
          echo "content of ${{env.TEMPORARY_FOLDER}}"
          ls -a ${{env.TEMPORARY_FOLDER}}
          echo "content of ${{env.OUTPUT_GENERATION}}"
          ls -a ${{env.OUTPUT_GENERATION}}
          echo "content of ${{env.LINUX_BINARY_FOLDER}}"
          ls -a ${{env.LINUX_BINARY_FOLDER}}
          echo "content of ${{env.MAC_INTEL_BINARY_FOLDER}}"
          ls -a ${{env.MAC_INTEL_BINARY_FOLDER}}
          echo "content of ${{env.MAC_MONE_BINARY_FOLDER}}"
          ls -a ${{env.MAC_MONE_BINARY_FOLDER}}
      - name: Create archives
        run: |
          echo "Listing the source"
          ls -a .
          echo "Listing the content of the folders at the source"
          ls -a ./*
      
      - name: Install the zip binary if not present
        run: |
          sudo apt update
          sudo apt install -y zip unzip
          # zip --version >/dev/null 2>&1
          # STATUS=$?
          # if [ $STATUS -ne 0 ]; then
          #   echo "::error file=<none>,line=0,endLine=0,title=zip is not installed::$STATUS"
          # fi

          # unzip --version >/dev/null 2>&1
          # STATUS=$?
          # if [ $STATUS -ne 0 ]; then
          #   echo "::error file=<none>,line=0,endLine=0,title=unzip is not installed::$STATUS"
          # fi
          # if [ $? -ne 0 ]; then 
          #   exit 0
          # fi
      
      - name: Compressing the folders into archives
        run: |
          COMMAND_OPTIONS="-0 -r"
          FORMATS=$(find ${{env.OUTPUT_GENERATION}} -maxdepth 1 -type d)
          echo "Found folders in the documentation: $FORMATS"
          echo "Generating archive of $(basename "${{env.OUTPUT_GENERATION}}")"
          zip $COMMAND_OPTIONS ${{env.DOCUMENTATION_ZIP_NAME}} $(basename "${{env.OUTPUT_GENERATION}}")
          echo "Generating archive of $(basename "${{env.LINUX_BINARY_FOLDER}}")"
          zip $COMMAND_OPTIONS ${{env.LINUX_ZIP_NAME}} $(basename "${{env.LINUX_BINARY_FOLDER}}")
          echo "Generating archive of $(basename "${{env.MAC_MONE_BINARY_FOLDER}}")"
          zip $COMMAND_OPTIONS ${{env.MAC_MON_ZIP_NAME}} $(basename "${{env.MAC_MONE_BINARY_FOLDER}}")
          echo "Generating archive of $(basename "${{env.MAC_INTEL_BINARY_FOLDER}}")"
          zip $COMMAND_OPTIONS ${{env.MAC_INTEL_ZIP_NAME}} $(basename "${{env.MAC_INTEL_BINARY_FOLDER}}")
          for item in ${FORMATS[@]}
          do
            echo "Creating zip archive: '$item'"
            zip $COMMAND_OPTIONS ${item}.zip $item
          done

      - name: Display generated archives
        run: |
          echo "Displaying files at the source of the repository"
          ls -a --color=auto
          echo "Displaying all zip files in ./"
          ls -a --color=auto *.zip 
          echo "Displaying all zip files in ${{env.OUTPUT_GENERATION}}/*.zip"
          ls -a --color=auto ${{env.OUTPUT_GENERATION}}/*.zip

      - name: Get folders of interest
        id: output-files
        run: |
          MMZN="${{env.MAC_MON_ZIP_NAME}}"
          MIZN="${{env.MAC_INTEL_ZIP_NAME}}"
          LZN="${{env.LINUX_ZIP_NAME}}"
          DZN="${{env.DOCUMENTATION_ZIP_NAME}}"
          OGRESULT="$(find ${{env.OUTPUT_GENERATION}} -maxdepth 1 -name '*.zip' -type f | tr '\n' ' ')"
          LBFRESULT="$(find ${{env.LINUX_BINARY_FOLDER}} -maxdepth 1 -type f | tr '\n' ' ')"
          MIBFRESULT="$(find ${{env.MAC_INTEL_BINARY_FOLDER}} -maxdepth 1 -type f | tr '\n' ' ')"
          MMBFRESULT="$(find ${{env.MAC_MONE_BINARY_FOLDER}} -maxdepth 1 -type f | tr '\n' ' ')"
          echo "MMZN=$MMZN" >> "$GITHUB_OUTPUT" # Files of interest
          echo "MIZN=$MIZN" >> "$GITHUB_OUTPUT" # Files of interest
          echo "LZN=$LZN" >> "$GITHUB_OUTPUT" # Files of interest
          echo "DZN=$DZN" >> "$GITHUB_OUTPUT" # Files of interest
          echo "OGRESULT=$OGRESULT" >> "$GITHUB_OUTPUT" # Files of interest
          echo "LBFRESULT=$LBFRESULT" >> "$GITHUB_OUTPUT" # Files of interest
          echo "MIBFRESULT=$MIBFRESULT" >> "$GITHUB_OUTPUT" # Files of interest
          echo "MMBFRESULT=$MMBFRESULT" >> "$GITHUB_OUTPUT" # Files of interest
          echo "MMZN=$MMZN"
          echo "MIZN=$MIZN"
          echo "LZN=$LZN"
          echo "DZN=$DZN"
          echo "OGRESULT=$OGRESULT"
          echo "LBFRESULT=$LBFRESULT"
          echo "MIBFRESULT=$MIBFRESULT"
          echo "MMBFRESULT=$MMBFRESULT"
          FILE_LIST="$MMZN $MIZN $LZN $DZN $OGRESULT $LBFRESULT $MIBFRESULT $MMBFRESULT"
          echo "Final file list='$FILE_LIST'"
          echo "FOI=$(echo $FILE_LIST | tr '\n' ' ')" >> "$GITHUB_OUTPUT" # Files of interest

      - name: Create a temporary load point
        id: anchor-point
        env:
          FILES_OF_INTEREST: ${{ steps.output-files.outputs.FOI }}
        run: |
          echo "In temporary load point"
          TEMPORARY_FOLDER=./tmp_data
          FILES_OF_INTEREST="${{ steps.output-files.outputs.FOI }}"
          echo "content of FILES_OF_INTEREST=$FILES_OF_INTEREST"
          mkdir -p $TEMPORARY_FOLDER
          for FILE in $FILES_OF_INTEREST; do
            cp -v "./$FILE" "$TEMPORARY_FOLDER"
          done
          echo "Loop finished"
          echo "Content of TEMPORARY_FOLDER:"
          ls -a "$TEMPORARY_FOLDER"
          echo "sending content to github output"
          {
            echo 'AP<<EOF'
            find ./$TEMPORARY_FOLDER -maxdepth 1 -type f
            echo EOF
          } >> "$GITHUB_OUTPUT" # anchor point


      - name: Publish binary as GitHub release
        uses: softprops/action-gh-release@v2
        if: startsWith(github.ref, 'refs/tags/')
        with:
          files: ${{ steps.anchor-point.outputs.AP}}
          name: ${{ env.COMMIT_TITLE }}
          body: ${{ env.COMMIT_MESSAGE }}
          draft: false
          prerelease: false
          make_latest: true
          token: ${{ secrets.GITHUB_TOKEN }}

  clean_created_cache:
    name: Clear the cache generated during the build time
    permissions: write-all
    runs-on: ubuntu-latest
    needs: [export_other_formats_when_present, publish_html ]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Delete Created cache
        env:
          GH_TOKEN: ${{ secrets.CACHE_TOKEN }}
        run: |
          gh cache list
          gh cache delete --all

